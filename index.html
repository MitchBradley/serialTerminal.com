<style>
    body {
        background-color: #505050;
    }
    * {
        /* background-color: #352e2e; */
        font-family: monospace;
        font-size: 18px;
        color: rgb(220, 220, 220);
        padding: 0px;
    }

    button,
    datalist {
        background-color: rgb(50, 50, 50);
        border-radius: 8px;
        border-style: double;
        padding: 5px;
    }

    input[type=text] {
        color: rgb(220, 220, 220);
        background-color: rgb(102, 102, 102);
        border: 1px solid;
        border-color: #696 #363 #363 #696;
        font-size: 18px;
        padding: 5px;
    }

    #serialResults {
        font-family: monospace;
        white-space: pre;
        height: calc(100% - 95px);
        width: calc(100% - 20px);
        border-style: none;
        overflow: scroll;
        background-color: rgb(64, 64, 64);
        padding: 5px;
        margin: 3px;
    }

    /* Modal Content/Box */
    .about-content {
        background-color: black;
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        
        /* Center in window */
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);

        padding: 20px;
        border: 1px solid #888;
        width: fit-content;
    }

/* The Close Button */
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
}

.close:hover,
.close:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FluidNC Web Terminal</title>
<meta name="Description" content="Hit connect.
A FluidNC-optimized serial terminal for Chrome and Edge.">
<div>
  <div style="display:flex; column-gap: 5px;">
    <button onclick="connectSerial()" id="connect">Connect</button>
    <button onclick="serialResultsDiv.innerHTML = '';">Clear</button>
    <button onclick="sendQuestion()">Status</button>
    <button onclick="resetESP32()">HardReset</button>
    <button onclick="resetGRBL()">SoftReset</button>
    <button onclick="unlock()">Unlock</button>
    <div style="flex:1; text-align: center; padding-top: 5px;">FluidNC Web Terminal</div>
    <button onclick="about()">About</button>
  </div>

  <div id="serialResults">
  </div>

  <div style="padding: 3px; display: flex; column-gap: 5px;">
    <input type="text" id="lineToSend" style="flex:1;">
    <button onclick="sendLineFromTextBox()">Send</button>
  </div>
</div>

<div id="about" class="about-content">
  <button class="close" onclick="unAbout();">&times; </button>
  <p>FluidNC Web Terminal by Mitch Bradley</p>
  <p>Based on Serial Terminal Â© 2021 Mike Molinari (mmiscool)<br>
    <a href="https://github.com/mmiscool/serialTerminal.com">https://github.com/mmiscool/serialTerminal.com</a>
  </p>
</div>
<script>
  var port, textEncoder, writableStreamClosed, writer, reader, readableStreamPromise;

  async function attachPort() {
      listenToPort();
      textEncoder = new TextEncoderStream();
      writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

      writer = textEncoder.writable.getWriter();
      document.getElementById("connect").innerHTML = "Disconnect";
  }
  async function closePort(event) {
      // I know of three cases where closePort() is called:
      // 1. If the user clicks on Disconnect, that calls reader.cancel() and then
      //    readableStreamPromise.catch() invokes closePort() with event == undefined.
      // 2. If the USB port is disconnected, readableStreamPromise.catch() invokes
      //    closePort() with event == DOMException:The device has been lost.
      // 3. Sometimes when you connect to the device after turning it on, it closes
      //    itself and you get event == DOMException:A buffer overrun has been detected.
      //    This appears to happen because the device has spewed a lot of text at
      //    startup and the low level code is unhappy about that.  In that case it is
      //    possible to recover by closing the various streams and then reopening them,
      //    without having to actually close the port and ask the user to reopen it.

      if (event && event.message && event.message == 'A buffer overrun has been detected.') {
          // This is case 3 as described above.  We try to recover and finish connecting
          writer.close();
          await writableStreamClosed;
          attachPort();
          return;
      }

      // Cases 1 and 2 as described above.  Shut down the port and disconnect.
      writer.close();
      await writableStreamClosed;
      await port.close();
      port = null;
      document.getElementById("connect").innerHTML = "Connect";
  }

  async function connectSerial() {
      if (document.getElementById("connect").innerHTML == "Disconnect") {
          // This will cause the read loop to throw an exception which,
          // when caught, will close the port
          reader.cancel();
          return;
      }
      try {
          try {
              // Prompt user to select any serial port.
              port = await navigator.serial.requestPort();
          } catch {
              return;
          }
          // await port.open({ baudRate: document.getElementById("baud").value });
          await port.open({ baudRate: 115200, bufferSize: 5000 });
          attachPort();
      } catch {
          alert("Serial Connection Failed");
          port = null;
      }
  }

  function disconnected() {
      if (!port) {
          alert("Not connected");
          return true;
      }
      return false;
  }

  async function send(msg) {
      if (disconnected()) {
          return;
      }
      await writer.write(msg);
  }
  async function sendLine(msg) {
      if (disconnected()) {
          return;
      }
      appendToTerminal('<span style="color:cyan;">' + msg + '</span><br>');
      send(msg + '\n');
  }

  async function sendQuestion() {
      send("?");
  }
  async function resetGRBL() {
      send("\x18");
  }
  async function unlock() {
      sendLine("$x");
  }
   
  async function resetESP32() {
      if (disconnected()) {
          return;
      }
      await port.setSignals({ dataTerminalReady: false });
      await port.setSignals({ requestToSend: true });
      setTimeout(function() {
          port.setSignals({ requestToSend: false });
      }, 500);
  }
   
  async function sendLineFromTextBox() {
      sendLine(document.getElementById("lineToSend").value);
  }

  function EntitiesHtml(string) {
      return String(string).replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
  }

  class Colorizer {
      constructor() {
          // A container for holding stream data until a new line.
          this.chunks = "";
      }

      transform(chunk, controller) {
          // Append new chunks to existing chunks.
          this.chunks += chunk;
          // For each line breaks in chunks, send the parsed lines out.
          const lines = this.chunks.split("\r\n");
          this.chunks = lines.pop();
          lines.forEach((line) => {
              line = EntitiesHtml(line);
              if (line.startsWith('[MSG:INFO')) {
                  line = '<span style="color:lime;">' + line + '</span>';
              } else if (line.startsWith('[MSG:ERR')) {
                  line = '<span style="color:red;">' + line + '</span>';
              } else if (line.startsWith('[MSG:WARN')) {
                  line = '<span style="color:yellow;">' + line + '</span>';
              } else if (line.startsWith('[MSG:DBG')) {
                  line = '<span style="color:yellow;">' + line + '</span>';
              }
              controller.enqueue(line+'<br>');
          });
      }

      flush(controller) {
          // When the stream is closed, flush any remaining chunks out.
          controller.enqueue(this.chunks);
      }
  }

  function bufferError(exc) {
      console.log("Buffer error");
  }

  async function listenToPort() {
      const textDecoder = new TextDecoderStream();
      readableStreamPromise = port.readable.pipeTo(textDecoder.writable);
      reader = textDecoder.readable
          .pipeThrough(new TransformStream(new Colorizer()))
          .getReader();
      var color = false;

      readableStreamPromise.catch((exc) => { closePort(exc); });

      // Listen to data coming from the serial device.
      while (true) {
          const { value, done } = await reader.read();
          if (done) {
              // Allow the serial port to be closed later.
              reader.releaseLock();
              break;
          }
          // value is a string.
          appendToTerminal(value);
      }
  }

  const serialResultsDiv = document.getElementById("serialResults");

  async function appendToTerminal(newStuff) {
      serialResultsDiv.innerHTML += newStuff;
      if (serialResultsDiv.innerHTML.length > 30000) serialResultsDiv.innerHTML = serialResultsDiv.innerHTML.slice(serialResultsDiv.innerHTML.length - 30000);

      //scroll down to bottom of div
      serialResultsDiv.scrollTop = serialResultsDiv.scrollHeight;
  }

  document.getElementById("lineToSend").addEventListener("keyup", async function (event) {
      if (event.keyCode === 13) {
          sendLineFromTextBox();
      }
  })

  var aboutBox = document.getElementById('about');
  
  function about() {
      aboutBox.style.display = "block";
  }
  function unAbout() {
      aboutBox.style.display = "none";
  }
  window.onclick = function(event) {
      if (event.target == aboutBox) {
          unAbout();
      }
  }

</script>
