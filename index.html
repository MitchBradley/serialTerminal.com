<style>
    body {
        background-color: #505050;
    }
    * {
        /* background-color: #352e2e; */
        font-family: monospace;
        font-size: 18px;
        color: rgb(220, 220, 220);
        padding: 0px;
    }

    button,
    datalist {
        background-color: rgb(50, 50, 50);
        border-radius: 8px;
        border-style: outset;
        padding: 5px;
    }

    input[type=text] {
        color: rgb(220, 220, 220);
        background-color: rgb(102, 102, 102);
        border: 1px solid;
        border-color: #696 #363 #363 #696;
        font-size: 18px;
        padding: 5px;
    }

    #serialResults {
        font-family: monospace;
        white-space: pre;
        height: calc(100% - 95px);
        width: calc(100% - 20px);
        border-style: none;
        overflow: scroll;
        background-color: rgb(64, 64, 64);
        padding: 5px;
        margin: 3px;
    }

    /* Modal Content/Box */
    .about-content {
        background-color: black;
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        
        /* Center in window */
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);

        padding: 20px;
        border: 1px solid #888;
        width: fit-content;
    }

/* The Close Button */
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
}

.close:hover,
.close:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FluidNC Web Terminal</title>
<meta name="Description" content="Hit connect.
A FluidNC-optimized serial terminal for Chrome and Edge.">
<div>
  <div style="display:flex; column-gap: 5px;">
    <button onclick="connectSerial()" id="connect">Connect</button>
    <button onclick="serialResultsDiv.innerHTML = '';">Clear</button>
    <button onclick="sendQuestion()">Status</button>
    <button onclick="resetESP32()">ResetESP32</button>
    <div style="flex:1; text-align: center; padding-top: 5px;">FluidNC Web Terminal</div>
    <button onclick="about()">About</button>
  </div>

  <div id="serialResults">
  </div>

  <div style="padding: 3px; display: flex; column-gap: 5px;">
    <input type="text" id="lineToSend" style="flex:1;">
    <button onclick="sendSerialLine()">Send</button>
  </div>
</div>

<div id="about" class="about-content">
  <button class="close" onclick="unAbout();">&times;</button>
  <p>FluidNC Web Terminal by Mitch Bradley</p>
  <p>Based on Serial Terminal Â© 2021 Mike Molinari (mmiscool)<br>
    <a href="https://github.com/mmiscool/serialTerminal.com">https://github.com/mmiscool/serialTerminal.com</a>
  </p>
</div>
<script>
  var port, textEncoder, writableStreamClosed, writer, reader, readableStreamClosed;

  async function connectSerial() {
      if (port) {
          reader.cancel();
          await readableStreamClosed.catch(() => { /* Ignore the error */ });

          writer.close();
          await writableStreamClosed;
          await port.close();
          port = null;
          document.getElementById("connect").innerHTML = "Connect";
          return;
      }
      try {
          // Prompt user to select any serial port.
          port = await navigator.serial.requestPort();
          // await port.open({ baudRate: document.getElementById("baud").value });
          await port.open({ baudRate: 115200 });
          listenToPort();

          textEncoder = new TextEncoderStream();
          writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

          writer = textEncoder.writable.getWriter();
          document.getElementById("connect").innerHTML = "Disconnect";
      } catch {
          alert("Serial Connection Failed");
          port = null;
      }
  }

  async function sendQuestion(){
      if (!port) {
          alert("Not connected");
          return;
      }
      await writer.write("?");
  }
   
  async function resetESP32(){
      if (!port) {
          alert("Not connected");
          return;
      }
      await port.setSignals({ dataTerminalReady: false });
      await port.setSignals({ requestToSend: true });
      setTimeout(function() {
          port.setSignals({ requestToSend: false });
      }, 500);
  }
   
  async function sendSerialLine() {
      if (!port) {
          alert("Not connected");
          return;
      }
      dataToSend = document.getElementById("lineToSend").value;
      appendToTerminal('<span style="color:cyan;">' + dataToSend + '</span><br>');
      dataToSend = dataToSend + "\n";
      await writer.write(dataToSend);
      //await writer.releaseLock();
  }

  function EntitiesHtml(string) {
      return String(string).replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
  }

  class Colorizer {
      constructor() {
          // A container for holding stream data until a new line.
          this.chunks = "";
      }

      transform(chunk, controller) {
          // Append new chunks to existing chunks.
          this.chunks += chunk;
          // For each line breaks in chunks, send the parsed lines out.
          const lines = this.chunks.split("\r\n");
          this.chunks = lines.pop();
          lines.forEach((line) => {
              line = EntitiesHtml(line);
              if (line.startsWith('[MSG:INFO')) {
                  line = '<span style="color:lime;">' + line + '</span>';
              } else if (line.startsWith('[MSG:ERR')) {
                  line = '<span style="color:red;">' + line + '</span>';
              } else if (line.startsWith('[MSG:WARN')) {
                  line = '<span style="color:yellow;">' + line + '</span>';
              } else if (line.startsWith('[MSG:DBG')) {
                  line = '<span style="color:yellow;">' + line + '</span>';
              }
              controller.enqueue(line+'<br>');
          });
      }

      flush(controller) {
          // When the stream is closed, flush any remaining chunks out.
          controller.enqueue(this.chunks);
      }
  }

  async function listenToPort() {
      const textDecoder = new TextDecoderStream();
      readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
      reader = textDecoder.readable
          .pipeThrough(new TransformStream(new Colorizer()))
          .getReader();
      var color = false;

      // Listen to data coming from the serial device.
      while (true) {
          const { value, done } = await reader.read();
          if (done) {
              // Allow the serial port to be closed later.
              reader.releaseLock();
              break;
          }
          // value is a string.
          appendToTerminal(value);
      }
  }

  const serialResultsDiv = document.getElementById("serialResults");

  async function appendToTerminal(newStuff) {
      serialResultsDiv.innerHTML += newStuff;
      if (serialResultsDiv.innerHTML.length > 30000) serialResultsDiv.innerHTML = serialResultsDiv.innerHTML.slice(serialResultsDiv.innerHTML.length - 30000);

      //scroll down to bottom of div
      serialResultsDiv.scrollTop = serialResultsDiv.scrollHeight;
  }

  document.getElementById("lineToSend").addEventListener("keyup", async function (event) {
      if (event.keyCode === 13) {
          sendSerialLine();
      }
  })

  var aboutBox = document.getElementById('about');
  
  function about() {
      aboutBox.style.display = "block";
  }
  function unAbout() {
      aboutBox.style.display = "none";
  }
  window.onclick = function(event) {
      if (event.target == aboutBox) {
          unAbout();
      }
  }

</script>
